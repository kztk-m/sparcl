-- Preamble
def (.) f g = \x -> f (g x)
fixity . 90 right

def ($) = \f x -> f x
fixity $ 0 right

sig fst : forall a b. (a, b) -> a
def fst (x, _) = x

sig snd : forall a b. (a, b) -> b
def snd (_, x) = x

sig fwd : forall a b. (rev a -o rev b) -> a -> b
def fwd = fst . unlift

sig bwd : forall a b. (rev a -o rev b) -> b -> a
def bwd = snd . unlift

sig const : forall a p q. (a # p -> a # q -> Bool) -> a -> rev a
def const eq c =
  lift (\() -> c)
       (\c' -> let True <- eq c c' in ())
       (rev ())

-- Bug 1
-- Consider the functions myFun and myFun' below.

sig myFun : rev c -o (rev c -o rev (c, a)) -o (rev d -o rev (d, (c, a)))
def myFun c rc d =
  let rev (c, a) <- rc c in
  rev (d, rev (c, a))

sig myFun' : rev c -o (rev c -o rev (c, a)) -o (rev d -o rev (d, (c, a)))
def myFun' c rc d = rev (d, rc c)

-- myFun and myFun' should be equivalent, but myFun produces incorrect results
-- and run-time errors whereas myFun' works without issue.

-- To reproduce:
-- Sparcl> fwd (myFun (const eqInt 1) (\c -> rev (c, const eqInt 2))) 100
-- <Tup 2> 1 (<Tup 2> 1 2)
--
-- Sparcl> bwd (myFun (const eqInt 1) (\c -> rev (c, const eqInt 2))) (1, (1, 2))
-- Runtime Error: Undefined addr

def inlined d = 
  let rev (c, a) <- rev (const eqInt 1, const eqInt 2)
  in rev (d, rev (c, a))
 


-- Bug 2
-- Consider the code below.

data List a = Nil | Cons a (List a)

sig null : List a -> Bool
def null Nil = True
       | _   = False

type Reader c a  = rev c -o rev (c, a)

sig return : rev a -o Reader c a
def return a c = rev (c, a)

sig bind : Reader c a -o (rev a -o Reader c b) -o Reader c b
def bind ra f c =
  let rev (c, a) <- ra c in
  f a c

sig withCtx : rev c -o Reader c a -o Reader d (c, a)
def withCtx c rc = return (rc c)

sig myFun2 : rev (List Int) -o Reader Int (List Int)
def myFun2 l n =
  case l of
  | rev Nil -> return (rev Nil) n with null . snd
  | rev (Cons x xs) ->
    let reader <-
      bind (withCtx x (myFun2 xs)) $ \xr -> let rev (x, r) <- xr in
      return (rev Cons x r)
    in reader n
  end

-- myFun2 type checks, but the evaluator gets stuck running it.

-- To reproduce:
-- Sparcl> fwd (\l -> myFun2 l (const eqInt 0)) (Cons 1 (Cons 2 Nil))
-- Runtime Error:
-- the first component of application must be a function.<reversible computation>
--
-- Sparcl> bwd (\l -> myFun2 l (const eqInt 0)) (0, Cons 1 (Cons 2 Nil))
-- Runtime Error:
-- the first component of application must be a function.<reversible computation>

-- The error does not occur when commenting out the call to withCtx as below.

sig myFun2' : rev (List Int) -o Reader Int (List Int)
def myFun2' l n =
  case l of
  | rev Nil -> return (rev Nil) n with null . snd
  | rev (Cons x xs) ->
    let reader <-
      bind (-- withCtx x
            (myFun2' xs)) $ \r -> -- \xr -> let rev (x, r) <- xr in
      return (rev Cons x r)
    in reader n
  end
